{"version":3,"sources":["marionette.toolkit.min.js","/source/src/mixins/state.js","/source/src/mixins/child-apps.js","/source/src/mixins/event-listeners.js","/source/src/app.js","/source/src/component.js","/source/src/marionette.toolkit.js"],"names":["global","factory","exports","module","require","define","amd","Marionette","Toolkit","_","Backbone","this","_$1","ClassOptions","StateMixin","StateModel","Model","initState","options","arguments","length","undefined","mergeOptions","_removeEventHandlers","_getStateModel","_stateModel","state","_setEventHandlers","unbindEntityEvents","stopListening","off","_destroyState","bindEntityEvents","result","on","prototype","isFunction","call","Error","name","message","setState","set","apply","resetStateDefaults","defaults","getState","attr","get","ChildAppsMixin","_initChildApps","_childApps","childApps","addChildApps","_initListeners","start","_startChildApps","before:stop","_stopChildApps","before:destroy","_destroyChildApps","each","childApp","stop","destroy","_buildAppFromObject","appConfig","AppClass","omit","buildApp","_buildApp","isObject","extend","childAppOptions","_ensureAppIsUnique","appName","addChildApp","_name","partial","_removeChildApp","isRunning","getName","getChildApps","clone","getChildApp","removeChildApps","removeChildApp","preventDestroy","EventListenersMixin","_stopRunningEvents","_runningEvents","args","_stopRunningListeners","_runningListeningTo","_isRunning","push","Object","listenTo","listenToOnce","App","_isDestroyed","startAfterInitialized","startWithParent","stopWithParent","constructor","bindAll","_ensureAppIsIntact","triggerMethod","triggerStart","restart","isDestroyed","ClassOpions","Component","ViewClass","ItemView","viewEventPrefix","viewOptions","_shouldDestroy","showIn","region","show","_isShown","renderView","_destroy","_getViewClass","View","mixinOptions","view","buildView","currentView","_proxyViewEvents","prefix","toArray","rootEvent","splice","attributes","_emptyRegion","empty","previousToolkit","noConflict","MixinState","classDefinition","_StateMixin","VERSION"],"mappings":"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","file":"marionette.toolkit.min.js","sourcesContent":["/**\n * marionette.toolkit - A collection of opinionated Backbone.Marionette extensions for large scale application architecture.\n * @version v1.0.0\n * @link https://github.com/RoundingWellOS/marionette.toolkit\n * @license MIT\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('backbone.marionette'), require('underscore'), require('backbone')) :\n  typeof define === 'function' && define.amd ? define(['backbone.marionette', 'underscore', 'backbone'], factory) :\n  (global.Marionette = global.Marionette || {}, global.Marionette.Toolkit = factory(global.Marionette,global._,global.Backbone));\n}(this, function (Marionette,_$1,Backbone) { 'use strict';\n\n  Marionette = 'default' in Marionette ? Marionette['default'] : Marionette;\n  _$1 = 'default' in _$1 ? _$1['default'] : _$1;\n  Backbone = 'default' in Backbone ? Backbone['default'] : Backbone;\n\n  var ClassOptions = ['StateModel', 'stateEvents'];\n\n  /**\n  * This provides methods used for keeping state using a Backbone.Model. It's meant to\n  * be used with either a Marionette.Object or Backbone.View.\n  *\n  * @mixin\n  */\n  var StateMixin = {\n\n    /**\n     * The model class for _stateModel.\n     * @type {Backbone.Model}\n     * @default Backbone.Model\n     */\n    StateModel: Backbone.Model,\n\n    /**\n     * @public\n     * @method initState\n     * @param {Object} [options] - Settings for the StateMixin.\n     * @param {Object} [options.stateEvents] - Event hash bound from _stateModel to StateMixin.\n     * @param {Backbone.Model} [options.StateModel] - Model class for _stateModel.\n     */\n    initState: function initState() {\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      // Make defaults available to this\n      this.mergeOptions(options, ClassOptions);\n\n      // Remove event handlers from previous state\n      this._removeEventHandlers();\n\n      var StateModel = this._getStateModel(options);\n\n      this._stateModel = new StateModel(options.state);\n\n      this._setEventHandlers();\n\n      return this;\n    },\n\n\n    /**\n     * Unbind all entity events and remove any listeners on _stateModel\n     * Clean up destroy event handler\n     *\n     * @private\n     * @method _removeEventHandlers\n     */\n    _removeEventHandlers: function _removeEventHandlers() {\n      if (!this._stateModel) return;\n\n      this.unbindEntityEvents(this._stateModel);\n      this._stateModel.stopListening();\n      this.off('destroy', this._destroyState);\n    },\n\n\n    /**\n     * Bind events from the _stateModel defined in stateEvents hash\n     * Setup destroy event handle\n     *\n     * @private\n     * @method _setEventHandlers\n     */\n    _setEventHandlers: function _setEventHandlers() {\n      this.bindEntityEvents(this._stateModel, _$1.result(this, 'stateEvents'));\n\n      this.on('destroy', this._destroyState);\n    },\n\n\n    /**\n     * Get the StateMixin StateModel class.\n     * Checks if the `StateModel` is a model class (the common case)\n     * Then check if it's a function (which we assume that returns a model class)\n     *\n     * @private\n     * @method _getStateModel\n     * @param {Object} [options] - Options that can be used to determine the StateModel.\n     * @returns {Backbone.Model}\n     */\n    _getStateModel: function _getStateModel(options) {\n      if (this.StateModel.prototype instanceof Backbone.Model || this.StateModel === Backbone.Model) {\n        return this.StateModel;\n      } else if (_$1.isFunction(this.StateModel)) {\n        return this.StateModel.call(this, options);\n      }\n\n      throw new Marionette.Error({\n        name: 'InvalidStateModelError',\n        message: '\"StateModel\" must be a model class or a function that returns a model class'\n      });\n    },\n\n\n    /**\n     * Set a property on the _stateModel.\n     *\n     * @public\n     * @method setState\n     * @param {String|Object} key - Attribute name or Hash of any number of key value pairs.\n     * @param {*} [value] - Attribute value if key is String, replaces options param otherwise.\n     * @param {Object} [options] - Backbone.Model options.\n     * @returns {Backbone.Model} - The _stateModel\n     */\n    setState: function setState() {\n      return this._stateModel.set.apply(this._stateModel, arguments);\n    },\n\n\n    /**\n     *  Reset _stateModel to defined defaults\n     *\n     * @public\n     * @method resetStateDefaults\n     * @param {Object} [newState] - Hash of any number of key value pairs.\n     * @returns {Backbone.Model|*} - The _stateModel or the attribute value of the _stateModel\n     */\n    resetStateDefaults: function resetStateDefaults() {\n      var defaults = _$1.result(this._stateModel, 'defaults');\n\n      return this._stateModel.set(defaults);\n    },\n\n\n    /**\n     * Get a property from the _stateModel, or return the _stateModel\n     *\n     * @public\n     * @method getState\n     * @param {String} [attr] - Attribute name of stateModel.\n     * @returns {Backbone.Model|*} - The _stateModel or the attribute value of the _stateModel\n     */\n    getState: function getState(attr) {\n      if (!attr) {\n        return this._stateModel;\n      }\n\n      return this._stateModel.get.apply(this._stateModel, arguments);\n    },\n\n\n    /**\n     * Clean up any listeners on the _stateModel.\n     *\n     * @private\n     * @method _destroyState\n     */\n    _destroyState: function _destroyState() {\n      this._stateModel.stopListening();\n    }\n  };\n\n  var ClassOptions$2 = ['childApps', 'childAppOptions'];\n\n  /**\n  * This provides methods used for \"App Manager\" functionality - the adding and removing child `App`s. It's not meant to\n  * be used directly.\n  *\n  * @mixin\n  */\n  var ChildAppsMixin = {\n\n    /**\n     * @private\n     * @method _initChildApps\n     * @constructs ChildApps\n     * @param {Object} [options] - Settings for the ChildApps.\n     * @param {Object} [options.childApps] - Hash for setting up child apps.\n     * @param {Object} [options.childAppOptions] - Hash of options passed to every child app.\n     *\n     * ```js\n     * childApps: {\n     *   appName: {\n     *     AppClass: MyChildAppClass,\n     *     fooOption: true,\n     *     startWithParent: true\n     *   },\n     *   barApp: MyOtherChildAppClass\n     * }\n     * ```\n     */\n\n    _initChildApps: function _initChildApps() {\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      this._childApps = {};\n\n      this.mergeOptions(options, ClassOptions$2);\n\n      var childApps = this.childApps;\n\n      if (childApps) {\n        if (_$1.isFunction(childApps)) {\n          childApps = childApps.call(this, options);\n        }\n\n        this.addChildApps(childApps);\n      }\n\n      this._initListeners();\n    },\n\n\n    /**\n     * The child apps should be handled while the app is running;\n     * After start, before stop, and before destroy.\n     *\n     * @private\n     * @method _initListeners\n     */\n    _initListeners: function _initListeners() {\n      this.on({\n        'start': this._startChildApps,\n        'before:stop': this._stopChildApps,\n        'before:destroy': this._destroyChildApps\n      });\n    },\n\n\n    /**\n     * Starts `childApps` if allowed by child\n     *\n     * @private\n     * @method _startChildApps\n     */\n    _startChildApps: function _startChildApps() {\n      _$1.each(this._childApps, function (childApp) {\n        if (_$1.result(childApp, 'startWithParent')) {\n          childApp.start();\n        }\n      });\n    },\n\n\n    /**\n     * Stops `childApps` if allowed by child\n     *\n     * @private\n     * @method _stopChildApps\n     */\n    _stopChildApps: function _stopChildApps() {\n      _$1.each(this._childApps, function (childApp) {\n        if (_$1.result(childApp, 'stopWithParent')) {\n          childApp.stop();\n        }\n      });\n    },\n\n\n    /**\n     * Destroys `childApps` if allowed by child\n     *\n     * @private\n     * @method _destroyChildApps\n     */\n    _destroyChildApps: function _destroyChildApps() {\n      _$1.each(this._childApps, function (childApp) {\n        if (!_$1.result(childApp, 'preventDestroy')) {\n          childApp.destroy();\n        }\n      });\n    },\n\n\n    /**\n     * Internal helper to instantiate and `App` from on `Object`\n     *\n     * @private\n     * @method _buildAppFromObject\n     * @param {Object} appConfig - `AppClass` and any other option for the `App`\n     * @returns {App}\n     */\n    _buildAppFromObject: function _buildAppFromObject(appConfig) {\n      var AppClass = appConfig.AppClass;\n      var options = _$1.omit(appConfig, 'AppClass');\n\n      return this.buildApp(AppClass, options);\n    },\n\n\n    /**\n     * Helper for building an App and return it\n     *\n     * @private\n     * @method _buildApp\n     * @param {App} AppClass - An App Class\n     * @param {Object} AppClass - Optionally passed as an appConfig Object\n     * @param {Object} [options] - options for the AppClass\n     * @returns {App}\n     */\n    _buildApp: function _buildApp(AppClass, options) {\n      if (_$1.isFunction(AppClass)) {\n        return this.buildApp(AppClass, options);\n      }\n      if (_$1.isObject(AppClass)) {\n        return this._buildAppFromObject(AppClass);\n      }\n    },\n\n\n    /**\n     * Build an App and return it\n     * Override for dynamic App building\n     *\n     * @public\n     * @method buildApp\n     * @param {App} [AppClass] - An App Class\n     * @param {Object} [options] - options for the AppClass\n     * @returns {App}\n     */\n    buildApp: function buildApp(AppClass, options) {\n      // options on childApp definition supersede childAppOptions\n      options = _$1.extend({}, this.childAppOptions, options);\n\n      return new AppClass(options);\n    },\n\n\n    /**\n     * Internal helper to verify `appName` is unique and not in use\n     *\n     * @private\n     * @method _ensureAppIsUnique\n     * @param {String} appName - Name of app to test\n     * @throws DuplicateChildAppError - Thrown if `App` already has an `appName` registered\n     */\n    _ensureAppIsUnique: function _ensureAppIsUnique(appName) {\n      if (this._childApps[appName]) {\n        throw new Marionette.Error({\n          name: 'DuplicateChildAppError',\n          message: 'A child App with name \"' + appName + '\" has already been added.'\n        });\n      }\n    },\n\n\n    /**\n     * Add child `App`s to this `App`\n     *\n     * @public\n     * @method addChildApps\n     * @param {Object} childApps - Hash of names and `AppClass` or `appConfig`\n     */\n    addChildApps: function addChildApps(childApps) {\n      _$1.each(childApps, function (childApp, appName) {\n        this.addChildApp(appName, childApp);\n      }, this);\n    },\n\n\n    /**\n     * Build's childApp and registers it with this App\n     * Starts the childApp, if this app is running and child is `startWithParent`\n     *\n     * @public\n     * @method addChildApp\n     * @param {String} appName - Name of App to register\n     * @param {App} AppClass - An App Class\n     * @param {Object} AppClass - Optionally passed as an appConfig Object\n     * @param {Object} [options] - options for the AppClass\n     * @throws AddChildAppError - Thrown if no childApp could be built from params\n     * @returns {App}\n     */\n    addChildApp: function addChildApp(appName, AppClass, options) {\n      this._ensureAppIsUnique(appName);\n\n      var childApp = this._buildApp(AppClass, options);\n\n      if (!childApp) {\n        throw new Marionette.Error({\n          name: 'AddChildAppError',\n          message: 'App build failed.  Incorrect configuration.'\n        });\n      }\n\n      childApp._name = appName;\n\n      this._childApps[appName] = childApp;\n\n      // When the app is destroyed remove the cached app.\n      childApp.on('destroy', _$1.partial(this._removeChildApp, appName), this);\n\n      if (this.isRunning() && _$1.result(childApp, 'startWithParent')) {\n        childApp.start();\n      }\n\n      return childApp;\n    },\n\n\n    /**\n     * Returns registered child `App`s name\n     *\n     * @public\n     * @method getName\n     * @returns {String}\n     */\n    getName: function getName() {\n      return this._name;\n    },\n\n\n    /**\n     * Returns registered child `App`s array\n     *\n     * @public\n     * @method getChildApps\n     * @returns {Array}\n     */\n    getChildApps: function getChildApps() {\n      return _$1.clone(this._childApps);\n    },\n\n\n    /**\n     * Returns registered child `App`\n     *\n     * @public\n     * @method getChildApp\n     * @param {String} appName - Name of App to retrieve\n     * @returns {App}\n     */\n    getChildApp: function getChildApp(appName) {\n      return this._childApps[appName];\n    },\n\n\n    /**\n     * Internal helper.  Unregisters child `App`\n     *\n     * @private\n     * @method _removeChildApp\n     * @param {String} appName - Name of App to unregister\n     * @returns {App}\n     */\n    _removeChildApp: function _removeChildApp(appName) {\n      delete this._childApps[appName]._name;\n      delete this._childApps[appName];\n    },\n\n\n    /**\n     * Removes all childApps and returns them.\n     * The return is useful if any app is using `preventDestroy`\n     *\n     * @public\n     * @method removeChildApps\n     * @returns {Array}\n     */\n    removeChildApps: function removeChildApps() {\n      var childApps = this.getChildApps();\n\n      _$1.each(this._childApps, function (childApp, appName) {\n        this.removeChildApp(appName);\n      }, this);\n\n      return childApps;\n    },\n\n\n    /**\n     * Destroys or removes registered child `App` by name\n     * depending on `preventDestroy`\n     *\n     * @public\n     * @method removeChildApp\n     * @param {String} appName - Name of App to destroy\n     * @param {Object} [options.preventDestroy] - Flag to remove but prevent App destroy\n     * @returns {App}\n     */\n    removeChildApp: function removeChildApp(appName, options) {\n      options = _$1.extend({}, options);\n\n      var childApp = this.getChildApp(appName);\n\n      if (!childApp) {\n        return;\n      }\n\n      // if preventDestroy simply unregister the child app\n      if (options.preventDestroy || _$1.result(childApp, 'preventDestroy')) {\n        this._removeChildApp(appName);\n      } else {\n        childApp.destroy();\n      }\n\n      return childApp;\n    }\n  };\n\n  /**\n  * This provides methods used for registering events while App is running and cleans them up at `onStop`. It's not meant to\n  * be used directly.\n  *\n  * @mixin\n  */\n\n  var EventListenersMixin = {\n    /**\n     * Internal method to stop any registered events.\n     *\n     * @private\n     * @method _stopRunningEvents\n     */\n\n    _stopRunningEvents: function _stopRunningEvents() {\n      _$1.each(this._runningEvents, function (args) {\n        this.off.apply(this, args);\n      }, this);\n    },\n\n\n    /**\n     * Internal method to stop any registered listeners.\n     *\n     * @private\n     * @method _stopRunningListeners\n     */\n    _stopRunningListeners: function _stopRunningListeners() {\n      _$1.each(this._runningListeningTo, function (args) {\n        this.stopListening.apply(this, args);\n      }, this);\n    },\n\n\n    /**\n     * Overrides `Backbone.Event.on()`\n     * If this `App` is running it will register the event for removal `onStop`\n     *\n     * @public\n     * @method on\n     * @returns {EventListeners}\n     */\n    on: function on() {\n      if (this._isRunning) {\n        this._runningEvents = this._runningEvents || [];\n        this._runningEvents.push(arguments);\n      }\n\n      return Marionette.Object.prototype.on.apply(this, arguments);\n    },\n\n\n    /**\n     * Overrides `Backbone.Event.listenTo()`\n     * If this `App` is running it will register the listener for removal `onStop`\n     *\n     * @public\n     * @method listenTo\n     * @returns {EventListeners}\n     */\n    listenTo: function listenTo() {\n      if (this._isRunning) {\n        this._runningListeningTo = this._runningListeningTo || [];\n        this._runningListeningTo.push(arguments);\n      }\n      return Marionette.Object.prototype.listenTo.apply(this, arguments);\n    },\n\n\n    /**\n     * Overrides `Backbone.Event.listenToOnce()`\n     * If this `App` is running it will register the listener for removal `onStop`\n     *\n     * @public\n     * @method listenToOnce\n     * @returns {EventListeners}\n     */\n    listenToOnce: function listenToOnce() {\n      if (this._isRunning) {\n        this._runningListeningTo = this._runningListeningTo || [];\n        this._runningListeningTo.push(arguments);\n      }\n\n      return Marionette.Object.prototype.listenToOnce.apply(this, arguments);\n    }\n  };\n\n  var ClassOptions$1 = ['startWithParent', 'stopWithParent', 'startAfterInitialized', 'preventDestroy'];\n\n  /**\n   * Marionette.Object with an `initialize` / `start` / `stop` / `destroy` lifecycle.\n   *\n   * @public\n   * @class App\n   * @memberOf Toolkit\n   * @memberOf Marionette\n   */\n  var App = Marionette.Object.extend({\n\n    /**\n     * Internal flag indiciate when `App` has started but has not yet stopped.\n     *\n     * @private\n     * @type {Boolean}\n     * @default false\n     */\n    _isRunning: false,\n\n    /**\n     * Internal flag indiciate when `App` has been destroyed\n     *\n     * @private\n     * @type {Boolean}\n     * @default false\n     */\n    _isDestroyed: false,\n\n    /**\n     * Set to true if a parent `App` should not be able to destroy this `App`.\n     *\n     * @type {Boolean|Function}\n     * @default false\n     */\n    preventDestroy: false,\n\n    /**\n     * Set to true if `App` should be started after it is initialized.\n     *\n     * @type {Boolean|Function}\n     * @default false\n     */\n    startAfterInitialized: false,\n\n    /**\n     * Set to true if `App` should be started after its parent starts.\n     *\n     * @type {Boolean|Function}\n     * @default false\n     */\n    startWithParent: false,\n\n    /**\n     * Set to false if `App` should not stop after its parent stops.\n     *\n     * @type {Boolean|Function}\n     * @default true\n     */\n    stopWithParent: true,\n\n    /**\n     * @public\n     * @constructs App\n     * @param {Object} [options] - Settings for the App.\n     * @param {Boolean} [options.startWithParent]\n     * @param {Boolean} [options.stopWithParent]\n     * @param {Boolean} [options.startAfterInitialized]\n     * @param {Boolean} [options.preventDestroy]\n     * @param {Object} [options.state] - Attributes to set on the state model.\n     */\n    constructor: function constructor() {\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      _$1.bindAll(this, 'start', 'stop');\n\n      this.mergeOptions(options, ClassOptions$1);\n\n      this.initState(options);\n      this._initChildApps(options);\n\n      Marionette.Object.call(this, options);\n\n      if (_$1.result(this, 'startAfterInitialized')) {\n        this.start(options);\n      }\n    },\n\n\n    /**\n     * Internal helper to verify if `App` has been destroyed\n     *\n     * @private\n     * @method _ensureAppIsIntact\n     * @memberOf App\n     * @throws AppDestroyedError - Thrown if `App` has already been destroyed\n     */\n    _ensureAppIsIntact: function _ensureAppIsIntact() {\n      if (this._isDestroyed) {\n        throw new Marionette.Error({\n          name: 'AppDestroyedError',\n          message: 'App has already been destroyed and cannot be used.'\n        });\n      }\n    },\n\n\n    /**\n     * Gets the value of internal `_isRunning` flag\n     *\n     * @public\n     * @method isRunning\n     * @memberOf App\n     * @returns {Boolean}\n     */\n    isRunning: function isRunning() {\n      return this._isRunning;\n    },\n\n\n    /**\n     * Sets the app lifecycle to running.\n     *\n     * @public\n     * @method start\n     * @memberOf App\n     * @param {Object} [options] - Settings for the App passed through to events\n     * @event App#before:start - passes options\n     * @returns {App}\n     */\n    start: function start(options) {\n      this._ensureAppIsIntact();\n\n      if (this._isRunning) {\n        return this;\n      }\n\n      this.triggerMethod('before:start', options);\n\n      this._isRunning = true;\n\n      this.triggerStart(options);\n\n      return this;\n    },\n\n\n    /**\n     * Triggers start event.\n     * Override to introduce async start\n     *\n     * @public\n     * @method triggerStart\n     * @memberOf App\n     * @param {Object} [options] - Settings for the App passed through to events\n     * @event App#start - passes options\n     * @returns\n     */\n    triggerStart: function triggerStart(options) {\n      this.triggerMethod('start', options);\n    },\n\n\n    /**\n     * \"Restarts the app\" by first stoping app, reinitializing state, and then starting the app again\n     *\n     *\n     * @public\n     * @method restart\n     * @memberOf App\n     * @param {Object} [options] - Settings for the App passed through to events\n     * @returns {App}\n     */\n    restart: function restart(options) {\n      this.stop(options);\n      this.initState(options);\n      this.start(options);\n\n      return this;\n    },\n\n\n    /**\n     * Sets the app lifecycle to not running.\n     * Removes any listeners added during the running state\n     *\n     * @public\n     * @method stop\n     * @memberOf App\n     * @param {Object} [options] - Settings for the App passed through to events\n     * @event App#before:stop - passes options\n     * @event App#stop - passes options\n     * @returns {App}\n     */\n    stop: function stop(options) {\n      if (!this._isRunning) {\n        return this;\n      }\n\n      this.triggerMethod('before:stop', options);\n\n      this._isRunning = false;\n\n      this.triggerMethod('stop', options);\n\n      this._stopRunningListeners();\n      this._stopRunningEvents();\n\n      return this;\n    },\n\n\n    /**\n     * Gets the value of internal `_isDestroyed` flag\n     *\n     * @public\n     * @method isDestroyed\n     * @memberOf App\n     * @returns {Boolean}\n     */\n    isDestroyed: function isDestroyed() {\n      return this._isDestroyed;\n    },\n\n\n    /**\n     * Stops the `App` and sets it destroyed.\n     *\n     * @public\n     * @method destroy\n     * @memberOf App\n     */\n    destroy: function destroy() {\n      if (this._isDestroyed) {\n        return;\n      }\n\n      this.stop();\n\n      Marionette.Object.prototype.destroy.apply(this, arguments);\n\n      this._isDestroyed = true;\n    }\n  });\n\n  _$1.extend(App.prototype, StateMixin, ChildAppsMixin, EventListenersMixin);\n\n  var ClassOpions = ['ViewClass', 'viewEventPrefix', 'viewOptions', 'region'];\n  /**\n   * Reusable Marionette.Object with View management boilerplate\n   *\n   * @public\n   * @class Component\n   * @memberOf Toolkit\n   * @memberOf Marionette\n   */\n  var Component = Marionette.Object.extend({\n\n    /**\n     * The view class to be managed.\n     * @type {Mn.ItemView|Mn.CollectionView|Mn.CompositeView|Mn.LayoutView}\n     * @default Marionette.ItemView\n     */\n    ViewClass: Marionette.ItemView,\n\n    /**\n     * Used as the prefix for events forwarded from\n     * the component's view to the component\n     * @type {String}\n     * @default 'view'\n     */\n    viewEventPrefix: 'view',\n\n    /**\n     * Options hash passed to the view when built.\n     * @type {Object|Function}\n     * @default '{}'\n     */\n    viewOptions: {},\n\n    /**\n     * @public\n     * @constructs Component\n     * @param {Object} [options] - Settings for the component.\n     * @param {Object} [options.state] - Attributes to set on the state model.\n     * @param {Mn.ItemView|Mn.CollectionView|Mn.CompositeView|Mn.LayoutView=} [options.ViewClass]\n     * - The view class to be managed.\n     * @param {String} [options.viewEventPrefix]\n     * - Used as the prefix for events forwarded from the component's view to the component\n     * @param {Object} [options.viewOptions] - Options hash passed to an instantiated ViewClass.\n     * @param {Marionette.Region} [options.region] - The region to show the component in.\n     */\n    constructor: function constructor() {\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      // Make defaults available to this\n      this.mergeOptions(options, ClassOpions);\n\n      this.initState(options);\n\n      Marionette.Object.call(this, options);\n    },\n\n\n    /**\n     * Internal flag to determine if the component should destroy.\n     * Set to false while showing the component's view in the component's region.\n     *\n     * @private\n     * @type {Boolean}\n     * @default true\n     */\n    _shouldDestroy: true,\n\n    /**\n     * Set the Component's region and then show it.\n     *\n     * @public\n     * @method showIn\n     * @memberOf Component\n     * @param {Marionette.Region} region - The region for the component\n     * @param {Object} [viewOptions] - Options hash mixed into the instantiated ViewClass.\n     * @returns {Component}\n     */\n    showIn: function showIn(region, viewOptions) {\n      this.region = region;\n\n      this.show(viewOptions);\n\n      return this;\n    },\n\n\n    /**\n     * Show the Component in its region.\n     *\n     * @public\n     * @event Component#before:show\n     * @event Component#show\n     * @throws ComponentShowError - Thrown if component has already been show.\n     * @throws ComponentRegionError - Thrown if component has no defined region.\n     * @method show\n     * @param {Object} [viewOptions] - Options hash mixed into the instantiated ViewClass.\n     * @memberOf Component\n     * @returns {Component}\n     */\n    show: function show(viewOptions) {\n      if (this._isShown) {\n        throw new Marionette.Error({\n          name: 'ComponentShowError',\n          message: 'Component has already been shown in a region.'\n        });\n      }\n\n      if (!this.region) {\n        throw new Marionette.Error({\n          name: 'ComponentRegionError',\n          message: 'Component has no defined region.'\n        });\n      }\n\n      this.triggerMethod('before:show');\n\n      this.renderView(viewOptions);\n      this._isShown = true;\n\n      this.triggerMethod('show');\n\n      // Destroy the component if the region is emptied because\n      // it destroys the view\n      this.listenTo(this.region, 'empty', this._destroy);\n\n      return this;\n    },\n\n\n    /**\n     * Get the Component ViewClass class.\n     * Checks if the `ViewClass` is a view class (the common case)\n     * Then check if it's a function (which we assume that returns a view class)\n     *\n     * @private\n     * @method _getViewClass\n     * @memberOf Component\n     * @param {Object} [options] - Options that can be used to determine the ViewClass.\n     * @returns {View}\n     */\n    _getViewClass: function _getViewClass() {\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var ViewClass = this.ViewClass;\n\n      if (ViewClass.prototype instanceof Backbone.View || ViewClass === Backbone.View) {\n        return ViewClass;\n      } else if (_$1.isFunction(ViewClass)) {\n        return ViewClass.call(this, options);\n      }\n\n      throw new Marionette.Error({\n        name: 'InvalidViewClassError',\n        message: '\"ViewClass\" must be a view class or a function that returns a view class'\n      });\n    },\n\n\n    /**\n     * Shows or re-shows a newly built view in the component's region\n     *\n     * @public\n     * @event Component#before:render:view\n     * @event Component#render:view\n     * @method renderView\n     * @memberOf Component\n     * @param {Object} [options] - Options hash mixed into the instantiated ViewClass.\n     * @returns {Component}\n     */\n    renderView: function renderView(options) {\n      var ViewClass = this._getViewClass(options);\n\n      var viewOptions = this.mixinOptions(options);\n\n      var view = this.buildView(ViewClass, viewOptions);\n\n      // Attach current built view to component\n      this.currentView = view;\n\n      this._proxyViewEvents(view);\n\n      this.triggerMethod('before:render:view', view);\n\n      // _shouldDestroy is flag that prevents the Component from being\n      // destroyed if the region is emptied by Component itself.\n      this._shouldDestroy = false;\n\n      // Show the view in the region\n      this.region.show(view);\n\n      this._shouldDestroy = true;\n\n      this.triggerMethod('render:view', view);\n\n      return this;\n    },\n\n\n    /**\n     * Proxies the ViewClass's viewEvents to the Component itself\n     * Similar to CollectionView childEvents\n     * (http://marionettejs.com/docs/v2.3.2/marionette.collectionview.html#collectionviews-childevents)\n     *\n     * @private\n     * @method _proxyViewEvents\n     * @memberOf Component\n     * @param {Mn.ItemView|Mn.CollectionView|Mn.CompositeView|Mn.LayoutView} view -\n     * The instantiated ViewClass.\n     */\n    _proxyViewEvents: function _proxyViewEvents(view) {\n      var prefix = this.viewEventPrefix;\n\n      view.on('all', function () {\n        var args = _$1.toArray(arguments);\n        var rootEvent = args[0];\n\n        args[0] = prefix + ':' + rootEvent;\n        args.splice(1, 0, view);\n\n        this.triggerMethod.apply(this, args);\n      }, this);\n    },\n\n\n    /**\n     * Mixin initial State with any other viewOptions\n     *\n     * @public\n     * @abstract\n     * @method mixinOptions\n     * @memberOf Component\n     * @param {Object} [options] - Additional options to mixin\n     * @returns {Object}\n     */\n    mixinOptions: function mixinOptions(options) {\n      var viewOptions = _$1.result(this, 'viewOptions');\n\n      return _$1.extend({ state: this.getState().attributes }, viewOptions, options);\n    },\n\n\n    /**\n     * Builds the view class with options\n     * If you need a dynamic ViewClass override this function\n     *\n     * @public\n     * @abstract\n     * @method buildView\n     * @memberOf Component\n     * @param {Mn.ItemView|Mn.CollectionView|Mn.CompositeView|Mn.LayoutView} ViewClass -\n     * The view class to instantiate.\n     * @param {Object} [viewOptions] - Options to pass to the View\n     * @returns {Mn.ItemView|Mn.CollectionView|Mn.CompositeView|Mn.LayoutView}\n     */\n    buildView: function buildView(ViewClass, viewOptions) {\n      return new ViewClass(viewOptions);\n    },\n\n\n    /**\n     * Destroys Component.\n     *\n     * @private\n     * @method _destroy\n     * @memberOf Component\n     */\n    _destroy: function _destroy() {\n      if (this._shouldDestroy) {\n        Marionette.Object.prototype.destroy.apply(this, arguments);\n      }\n    },\n\n\n    /**\n     * Empties component's region.\n     *\n     * @private\n     * @method _emptyRegion\n     * @param {Object} [options] - Options passed to `region.empty`\n     * @memberOf Component\n     */\n    _emptyRegion: function _emptyRegion(options) {\n      if (this.region) {\n        this.stopListening(this.region, 'empty');\n        this.region.empty(options);\n      }\n    },\n\n\n    /**\n     * Empty the region and destroy the component.\n     *\n     * @public\n     * @method destroy\n     * @param {Object} [options] - Options passed to `_emptyRegion` and `destroy`\n     * @memberOf Component\n     */\n    destroy: function destroy(options) {\n      this._emptyRegion(options);\n\n      this._shouldDestroy = true;\n\n      this._destroy(options);\n    }\n  });\n\n  _$1.extend(Component.prototype, StateMixin);\n\n  /**\n   * @module Toolkit\n   */\n\n  var previousToolkit = Marionette.Toolkit;\n\n  var Toolkit = Marionette.Toolkit = {};\n\n  Toolkit.noConflict = function () {\n    Marionette.Toolkit = previousToolkit;\n    return this;\n  };\n\n  Toolkit.MixinState = function (classDefinition) {\n    var _StateMixin = StateMixin;\n\n    if (classDefinition.prototype.StateModel) {\n      _StateMixin = _.omit(StateMixin, 'StateModel');\n    }\n\n    _.extend(classDefinition.prototype, _StateMixin);\n  };\n\n  Toolkit.VERSION = '1.0.0';\n\n  Toolkit.StateMixin = StateMixin;\n\n  Toolkit.App = App;\n\n  Toolkit.Component = Component;\n\n  return Toolkit;\n\n}));\n\n//# sourceMappingURL=marionette.toolkit.js.map\n","import _ from 'underscore';\nimport Backbone from 'backbone';\nimport Marionette from 'backbone.marionette';\n\nconst ClassOptions = [\n  'StateModel',\n  'stateEvents'\n];\n\n /**\n * This provides methods used for keeping state using a Backbone.Model. It's meant to\n * be used with either a Marionette.Object or Backbone.View.\n *\n * @mixin\n */\nexport default {\n\n  /**\n   * The model class for _stateModel.\n   * @type {Backbone.Model}\n   * @default Backbone.Model\n   */\n  StateModel: Backbone.Model,\n\n  /**\n   * @public\n   * @method initState\n   * @param {Object} [options] - Settings for the StateMixin.\n   * @param {Object} [options.stateEvents] - Event hash bound from _stateModel to StateMixin.\n   * @param {Backbone.Model} [options.StateModel] - Model class for _stateModel.\n   */\n  initState(options = {}) {\n    // Make defaults available to this\n    this.mergeOptions(options, ClassOptions);\n\n    // Remove event handlers from previous state\n    this._removeEventHandlers();\n\n    const StateModel = this._getStateModel(options);\n\n    this._stateModel = new StateModel(options.state);\n\n    this._setEventHandlers();\n\n    return this;\n  },\n\n  /**\n   * Unbind all entity events and remove any listeners on _stateModel\n   * Clean up destroy event handler\n   *\n   * @private\n   * @method _removeEventHandlers\n   */\n  _removeEventHandlers() {\n    if(!this._stateModel) return;\n\n    this.unbindEntityEvents(this._stateModel);\n    this._stateModel.stopListening();\n    this.off('destroy', this._destroyState);\n  },\n\n  /**\n   * Bind events from the _stateModel defined in stateEvents hash\n   * Setup destroy event handle\n   *\n   * @private\n   * @method _setEventHandlers\n   */\n  _setEventHandlers() {\n    this.bindEntityEvents(this._stateModel, _.result(this, 'stateEvents'));\n\n    this.on('destroy', this._destroyState);\n  },\n\n  /**\n   * Get the StateMixin StateModel class.\n   * Checks if the `StateModel` is a model class (the common case)\n   * Then check if it's a function (which we assume that returns a model class)\n   *\n   * @private\n   * @method _getStateModel\n   * @param {Object} [options] - Options that can be used to determine the StateModel.\n   * @returns {Backbone.Model}\n   */\n  _getStateModel(options) {\n    if(this.StateModel.prototype instanceof Backbone.Model || this.StateModel === Backbone.Model) {\n      return this.StateModel;\n    } else if(_.isFunction(this.StateModel)) {\n      return this.StateModel.call(this, options);\n    }\n\n    throw new Marionette.Error({\n      name: 'InvalidStateModelError',\n      message: '\"StateModel\" must be a model class or a function that returns a model class'\n    });\n  },\n\n  /**\n   * Set a property on the _stateModel.\n   *\n   * @public\n   * @method setState\n   * @param {String|Object} key - Attribute name or Hash of any number of key value pairs.\n   * @param {*} [value] - Attribute value if key is String, replaces options param otherwise.\n   * @param {Object} [options] - Backbone.Model options.\n   * @returns {Backbone.Model} - The _stateModel\n   */\n  setState() {\n    return this._stateModel.set.apply(this._stateModel, arguments);\n  },\n\n\n  /**\n   *  Reset _stateModel to defined defaults\n   *\n   * @public\n   * @method resetStateDefaults\n   * @param {Object} [newState] - Hash of any number of key value pairs.\n   * @returns {Backbone.Model|*} - The _stateModel or the attribute value of the _stateModel\n   */\n  resetStateDefaults() {\n    const defaults = _.result(this._stateModel, 'defaults');\n\n    return this._stateModel.set(defaults);\n  },\n\n  /**\n   * Get a property from the _stateModel, or return the _stateModel\n   *\n   * @public\n   * @method getState\n   * @param {String} [attr] - Attribute name of stateModel.\n   * @returns {Backbone.Model|*} - The _stateModel or the attribute value of the _stateModel\n   */\n  getState(attr) {\n    if(!attr) {\n      return this._stateModel;\n    }\n\n    return this._stateModel.get.apply(this._stateModel, arguments);\n  },\n\n  /**\n   * Clean up any listeners on the _stateModel.\n   *\n   * @private\n   * @method _destroyState\n   */\n  _destroyState() {\n    this._stateModel.stopListening();\n  }\n};\n","import _ from 'underscore';\nimport Marionette from 'backbone.marionette';\n\nconst ClassOptions = [\n  'childApps',\n  'childAppOptions'\n];\n\n /**\n * This provides methods used for \"App Manager\" functionality - the adding and removing child `App`s. It's not meant to\n * be used directly.\n *\n * @mixin\n */\nexport default {\n\n  /**\n   * @private\n   * @method _initChildApps\n   * @constructs ChildApps\n   * @param {Object} [options] - Settings for the ChildApps.\n   * @param {Object} [options.childApps] - Hash for setting up child apps.\n   * @param {Object} [options.childAppOptions] - Hash of options passed to every child app.\n   *\n   * ```js\n   * childApps: {\n   *   appName: {\n   *     AppClass: MyChildAppClass,\n   *     fooOption: true,\n   *     startWithParent: true\n   *   },\n   *   barApp: MyOtherChildAppClass\n   * }\n   * ```\n   */\n  _initChildApps(options = {}) {\n    this._childApps = {};\n\n    this.mergeOptions(options, ClassOptions);\n\n    let childApps = this.childApps;\n\n    if(childApps) {\n      if(_.isFunction(childApps)) {\n        childApps = childApps.call(this, options);\n      }\n\n      this.addChildApps(childApps);\n    }\n\n    this._initListeners();\n  },\n\n  /**\n   * The child apps should be handled while the app is running;\n   * After start, before stop, and before destroy.\n   *\n   * @private\n   * @method _initListeners\n   */\n  _initListeners() {\n    this.on({\n      'start': this._startChildApps,\n      'before:stop': this._stopChildApps,\n      'before:destroy': this._destroyChildApps\n    });\n  },\n\n  /**\n   * Starts `childApps` if allowed by child\n   *\n   * @private\n   * @method _startChildApps\n   */\n  _startChildApps() {\n    _.each(this._childApps, function(childApp) {\n      if(_.result(childApp, 'startWithParent')) {\n        childApp.start();\n      }\n    });\n  },\n\n  /**\n   * Stops `childApps` if allowed by child\n   *\n   * @private\n   * @method _stopChildApps\n   */\n  _stopChildApps() {\n    _.each(this._childApps, function(childApp) {\n      if(_.result(childApp, 'stopWithParent')) {\n        childApp.stop();\n      }\n    });\n  },\n\n  /**\n   * Destroys `childApps` if allowed by child\n   *\n   * @private\n   * @method _destroyChildApps\n   */\n  _destroyChildApps() {\n    _.each(this._childApps, function(childApp) {\n      if(!_.result(childApp, 'preventDestroy')) {\n        childApp.destroy();\n      }\n    });\n  },\n\n  /**\n   * Internal helper to instantiate and `App` from on `Object`\n   *\n   * @private\n   * @method _buildAppFromObject\n   * @param {Object} appConfig - `AppClass` and any other option for the `App`\n   * @returns {App}\n   */\n  _buildAppFromObject(appConfig) {\n    const AppClass = appConfig.AppClass;\n    const options = _.omit(appConfig, 'AppClass');\n\n    return this.buildApp(AppClass, options);\n  },\n\n  /**\n   * Helper for building an App and return it\n   *\n   * @private\n   * @method _buildApp\n   * @param {App} AppClass - An App Class\n   * @param {Object} AppClass - Optionally passed as an appConfig Object\n   * @param {Object} [options] - options for the AppClass\n   * @returns {App}\n   */\n  _buildApp(AppClass, options) {\n    if(_.isFunction(AppClass)) {\n      return this.buildApp(AppClass, options);\n    }\n    if(_.isObject(AppClass)) {\n      return this._buildAppFromObject(AppClass);\n    }\n  },\n\n  /**\n   * Build an App and return it\n   * Override for dynamic App building\n   *\n   * @public\n   * @method buildApp\n   * @param {App} [AppClass] - An App Class\n   * @param {Object} [options] - options for the AppClass\n   * @returns {App}\n   */\n  buildApp(AppClass, options) {\n    // options on childApp definition supersede childAppOptions\n    options = _.extend({}, this.childAppOptions, options);\n\n    return new AppClass(options);\n  },\n\n  /**\n   * Internal helper to verify `appName` is unique and not in use\n   *\n   * @private\n   * @method _ensureAppIsUnique\n   * @param {String} appName - Name of app to test\n   * @throws DuplicateChildAppError - Thrown if `App` already has an `appName` registered\n   */\n  _ensureAppIsUnique(appName) {\n    if(this._childApps[appName]) {\n      throw new Marionette.Error({\n        name: 'DuplicateChildAppError',\n        message: `A child App with name \"${ appName }\" has already been added.`\n      });\n    }\n  },\n\n  /**\n   * Add child `App`s to this `App`\n   *\n   * @public\n   * @method addChildApps\n   * @param {Object} childApps - Hash of names and `AppClass` or `appConfig`\n   */\n  addChildApps(childApps) {\n    _.each(childApps, function(childApp, appName) {\n      this.addChildApp(appName, childApp);\n    }, this);\n  },\n\n  /**\n   * Build's childApp and registers it with this App\n   * Starts the childApp, if this app is running and child is `startWithParent`\n   *\n   * @public\n   * @method addChildApp\n   * @param {String} appName - Name of App to register\n   * @param {App} AppClass - An App Class\n   * @param {Object} AppClass - Optionally passed as an appConfig Object\n   * @param {Object} [options] - options for the AppClass\n   * @throws AddChildAppError - Thrown if no childApp could be built from params\n   * @returns {App}\n   */\n  addChildApp(appName, AppClass, options) {\n    this._ensureAppIsUnique(appName);\n\n    const childApp = this._buildApp(AppClass, options);\n\n    if(!childApp) {\n      throw new Marionette.Error({\n        name: 'AddChildAppError',\n        message: 'App build failed.  Incorrect configuration.'\n      });\n    }\n\n    childApp._name = appName;\n\n    this._childApps[appName] = childApp;\n\n    // When the app is destroyed remove the cached app.\n    childApp.on('destroy', _.partial(this._removeChildApp, appName), this);\n\n    if(this.isRunning() && _.result(childApp, 'startWithParent')) {\n      childApp.start();\n    }\n\n    return childApp;\n  },\n\n  /**\n   * Returns registered child `App`s name\n   *\n   * @public\n   * @method getName\n   * @returns {String}\n   */\n  getName() {\n    return this._name;\n  },\n\n\n  /**\n   * Returns registered child `App`s array\n   *\n   * @public\n   * @method getChildApps\n   * @returns {Array}\n   */\n  getChildApps() {\n    return _.clone(this._childApps);\n  },\n\n  /**\n   * Returns registered child `App`\n   *\n   * @public\n   * @method getChildApp\n   * @param {String} appName - Name of App to retrieve\n   * @returns {App}\n   */\n  getChildApp(appName) {\n    return this._childApps[appName];\n  },\n\n  /**\n   * Internal helper.  Unregisters child `App`\n   *\n   * @private\n   * @method _removeChildApp\n   * @param {String} appName - Name of App to unregister\n   * @returns {App}\n   */\n  _removeChildApp(appName) {\n    delete this._childApps[appName]._name;\n    delete this._childApps[appName];\n  },\n\n  /**\n   * Removes all childApps and returns them.\n   * The return is useful if any app is using `preventDestroy`\n   *\n   * @public\n   * @method removeChildApps\n   * @returns {Array}\n   */\n  removeChildApps() {\n    const childApps = this.getChildApps();\n\n    _.each(this._childApps, function(childApp, appName) {\n      this.removeChildApp(appName);\n    }, this);\n\n    return childApps;\n  },\n\n  /**\n   * Destroys or removes registered child `App` by name\n   * depending on `preventDestroy`\n   *\n   * @public\n   * @method removeChildApp\n   * @param {String} appName - Name of App to destroy\n   * @param {Object} [options.preventDestroy] - Flag to remove but prevent App destroy\n   * @returns {App}\n   */\n  removeChildApp(appName, options) {\n    options = _.extend({}, options);\n\n    const childApp = this.getChildApp(appName);\n\n    if(!childApp) {\n      return;\n    }\n\n    // if preventDestroy simply unregister the child app\n    if(options.preventDestroy || _.result(childApp, 'preventDestroy')) {\n      this._removeChildApp(appName);\n    } else {\n      childApp.destroy();\n    }\n\n    return childApp;\n  }\n};\n","import _ from 'underscore';\nimport Marionette from 'backbone.marionette';\n\n /**\n * This provides methods used for registering events while App is running and cleans them up at `onStop`. It's not meant to\n * be used directly.\n *\n * @mixin\n */\n\nexport default {\n  /**\n   * Internal method to stop any registered events.\n   *\n   * @private\n   * @method _stopRunningEvents\n   */\n  _stopRunningEvents() {\n    _.each(this._runningEvents, function(args) {\n      this.off.apply(this, args);\n    }, this);\n  },\n\n  /**\n   * Internal method to stop any registered listeners.\n   *\n   * @private\n   * @method _stopRunningListeners\n   */\n  _stopRunningListeners() {\n    _.each(this._runningListeningTo, function(args) {\n      this.stopListening.apply(this, args);\n    }, this);\n  },\n\n  /**\n   * Overrides `Backbone.Event.on()`\n   * If this `App` is running it will register the event for removal `onStop`\n   *\n   * @public\n   * @method on\n   * @returns {EventListeners}\n   */\n  on() {\n    if(this._isRunning) {\n      this._runningEvents = (this._runningEvents || []);\n      this._runningEvents.push(arguments);\n    }\n\n    return Marionette.Object.prototype.on.apply(this, arguments);\n  },\n\n  /**\n   * Overrides `Backbone.Event.listenTo()`\n   * If this `App` is running it will register the listener for removal `onStop`\n   *\n   * @public\n   * @method listenTo\n   * @returns {EventListeners}\n   */\n  listenTo() {\n    if(this._isRunning) {\n      this._runningListeningTo = (this._runningListeningTo || []);\n      this._runningListeningTo.push(arguments);\n    }\n    return Marionette.Object.prototype.listenTo.apply(this, arguments);\n  },\n\n  /**\n   * Overrides `Backbone.Event.listenToOnce()`\n   * If this `App` is running it will register the listener for removal `onStop`\n   *\n   * @public\n   * @method listenToOnce\n   * @returns {EventListeners}\n   */\n  listenToOnce() {\n    if(this._isRunning) {\n      this._runningListeningTo = (this._runningListeningTo || []);\n      this._runningListeningTo.push(arguments);\n    }\n\n    return Marionette.Object.prototype.listenToOnce.apply(this, arguments);\n  }\n};\n","import _ from 'underscore';\nimport Marionette from 'backbone.marionette';\nimport StateMixin from './mixins/state';\nimport ChildAppsMixin from './mixins/child-apps';\nimport EventListenersMixin from './mixins/event-listeners';\n\nconst ClassOptions = [\n  'startWithParent',\n  'stopWithParent',\n  'startAfterInitialized',\n  'preventDestroy'\n];\n\n/**\n * Marionette.Object with an `initialize` / `start` / `stop` / `destroy` lifecycle.\n *\n * @public\n * @class App\n * @memberOf Toolkit\n * @memberOf Marionette\n */\nconst App = Marionette.Object.extend({\n\n  /**\n   * Internal flag indiciate when `App` has started but has not yet stopped.\n   *\n   * @private\n   * @type {Boolean}\n   * @default false\n   */\n  _isRunning: false,\n\n  /**\n   * Internal flag indiciate when `App` has been destroyed\n   *\n   * @private\n   * @type {Boolean}\n   * @default false\n   */\n  _isDestroyed: false,\n\n  /**\n   * Set to true if a parent `App` should not be able to destroy this `App`.\n   *\n   * @type {Boolean|Function}\n   * @default false\n   */\n  preventDestroy: false,\n\n  /**\n   * Set to true if `App` should be started after it is initialized.\n   *\n   * @type {Boolean|Function}\n   * @default false\n   */\n  startAfterInitialized: false,\n\n  /**\n   * Set to true if `App` should be started after its parent starts.\n   *\n   * @type {Boolean|Function}\n   * @default false\n   */\n  startWithParent: false,\n\n  /**\n   * Set to false if `App` should not stop after its parent stops.\n   *\n   * @type {Boolean|Function}\n   * @default true\n   */\n  stopWithParent: true,\n\n  /**\n   * @public\n   * @constructs App\n   * @param {Object} [options] - Settings for the App.\n   * @param {Boolean} [options.startWithParent]\n   * @param {Boolean} [options.stopWithParent]\n   * @param {Boolean} [options.startAfterInitialized]\n   * @param {Boolean} [options.preventDestroy]\n   * @param {Object} [options.state] - Attributes to set on the state model.\n   */\n  constructor(options = {}) {\n    _.bindAll(this, 'start', 'stop');\n\n    this.mergeOptions(options, ClassOptions);\n\n    this.initState(options);\n    this._initChildApps(options);\n\n    Marionette.Object.call(this, options);\n\n    if(_.result(this, 'startAfterInitialized')) {\n      this.start(options);\n    }\n  },\n\n  /**\n   * Internal helper to verify if `App` has been destroyed\n   *\n   * @private\n   * @method _ensureAppIsIntact\n   * @memberOf App\n   * @throws AppDestroyedError - Thrown if `App` has already been destroyed\n   */\n  _ensureAppIsIntact() {\n    if(this._isDestroyed) {\n      throw new Marionette.Error({\n        name: 'AppDestroyedError',\n        message: 'App has already been destroyed and cannot be used.'\n      });\n    }\n  },\n\n  /**\n   * Gets the value of internal `_isRunning` flag\n   *\n   * @public\n   * @method isRunning\n   * @memberOf App\n   * @returns {Boolean}\n   */\n  isRunning() {\n    return this._isRunning;\n  },\n\n  /**\n   * Sets the app lifecycle to running.\n   *\n   * @public\n   * @method start\n   * @memberOf App\n   * @param {Object} [options] - Settings for the App passed through to events\n   * @event App#before:start - passes options\n   * @returns {App}\n   */\n  start(options) {\n    this._ensureAppIsIntact();\n\n    if(this._isRunning) {\n      return this;\n    }\n\n    this.triggerMethod('before:start', options);\n\n    this._isRunning = true;\n\n    this.triggerStart(options);\n\n    return this;\n  },\n\n  /**\n   * Triggers start event.\n   * Override to introduce async start\n   *\n   * @public\n   * @method triggerStart\n   * @memberOf App\n   * @param {Object} [options] - Settings for the App passed through to events\n   * @event App#start - passes options\n   * @returns\n   */\n  triggerStart(options) {\n    this.triggerMethod('start', options);\n  },\n\n  /**\n   * \"Restarts the app\" by first stoping app, reinitializing state, and then starting the app again\n   *\n   *\n   * @public\n   * @method restart\n   * @memberOf App\n   * @param {Object} [options] - Settings for the App passed through to events\n   * @returns {App}\n   */\n  restart(options) {\n    this.stop(options);\n    this.initState(options);\n    this.start(options);\n\n    return this;\n  },\n\n  /**\n   * Sets the app lifecycle to not running.\n   * Removes any listeners added during the running state\n   *\n   * @public\n   * @method stop\n   * @memberOf App\n   * @param {Object} [options] - Settings for the App passed through to events\n   * @event App#before:stop - passes options\n   * @event App#stop - passes options\n   * @returns {App}\n   */\n  stop(options) {\n    if(!this._isRunning) {\n      return this;\n    }\n\n    this.triggerMethod('before:stop', options);\n\n    this._isRunning = false;\n\n    this.triggerMethod('stop', options);\n\n    this._stopRunningListeners();\n    this._stopRunningEvents();\n\n    return this;\n  },\n\n  /**\n   * Gets the value of internal `_isDestroyed` flag\n   *\n   * @public\n   * @method isDestroyed\n   * @memberOf App\n   * @returns {Boolean}\n   */\n  isDestroyed() {\n    return this._isDestroyed;\n  },\n\n  /**\n   * Stops the `App` and sets it destroyed.\n   *\n   * @public\n   * @method destroy\n   * @memberOf App\n   */\n  destroy() {\n    if(this._isDestroyed) {\n      return;\n    }\n\n    this.stop();\n\n    Marionette.Object.prototype.destroy.apply(this, arguments);\n\n    this._isDestroyed = true;\n  }\n});\n\n_.extend(App.prototype, StateMixin, ChildAppsMixin, EventListenersMixin);\n\nexport default App;\n","import _ from 'underscore';\nimport Backbone from 'backbone';\nimport Marionette from 'backbone.marionette';\nimport StateMixin from './mixins/state';\n\nconst ClassOpions = [\n  'ViewClass',\n  'viewEventPrefix',\n  'viewOptions',\n  'region'\n];\n/**\n * Reusable Marionette.Object with View management boilerplate\n *\n * @public\n * @class Component\n * @memberOf Toolkit\n * @memberOf Marionette\n */\nconst Component = Marionette.Object.extend({\n\n  /**\n   * The view class to be managed.\n   * @type {Mn.ItemView|Mn.CollectionView|Mn.CompositeView|Mn.LayoutView}\n   * @default Marionette.ItemView\n   */\n  ViewClass: Marionette.ItemView,\n\n  /**\n   * Used as the prefix for events forwarded from\n   * the component's view to the component\n   * @type {String}\n   * @default 'view'\n   */\n  viewEventPrefix: 'view',\n\n  /**\n   * Options hash passed to the view when built.\n   * @type {Object|Function}\n   * @default '{}'\n   */\n  viewOptions: {},\n\n  /**\n   * @public\n   * @constructs Component\n   * @param {Object} [options] - Settings for the component.\n   * @param {Object} [options.state] - Attributes to set on the state model.\n   * @param {Mn.ItemView|Mn.CollectionView|Mn.CompositeView|Mn.LayoutView=} [options.ViewClass]\n   * - The view class to be managed.\n   * @param {String} [options.viewEventPrefix]\n   * - Used as the prefix for events forwarded from the component's view to the component\n   * @param {Object} [options.viewOptions] - Options hash passed to an instantiated ViewClass.\n   * @param {Marionette.Region} [options.region] - The region to show the component in.\n   */\n  constructor(options = {}) {\n    // Make defaults available to this\n    this.mergeOptions(options, ClassOpions);\n\n    this.initState(options);\n\n    Marionette.Object.call(this, options);\n  },\n\n  /**\n   * Internal flag to determine if the component should destroy.\n   * Set to false while showing the component's view in the component's region.\n   *\n   * @private\n   * @type {Boolean}\n   * @default true\n   */\n  _shouldDestroy: true,\n\n  /**\n   * Set the Component's region and then show it.\n   *\n   * @public\n   * @method showIn\n   * @memberOf Component\n   * @param {Marionette.Region} region - The region for the component\n   * @param {Object} [viewOptions] - Options hash mixed into the instantiated ViewClass.\n   * @returns {Component}\n   */\n  showIn(region, viewOptions) {\n    this.region = region;\n\n    this.show(viewOptions);\n\n    return this;\n  },\n\n  /**\n   * Show the Component in its region.\n   *\n   * @public\n   * @event Component#before:show\n   * @event Component#show\n   * @throws ComponentShowError - Thrown if component has already been show.\n   * @throws ComponentRegionError - Thrown if component has no defined region.\n   * @method show\n   * @param {Object} [viewOptions] - Options hash mixed into the instantiated ViewClass.\n   * @memberOf Component\n   * @returns {Component}\n   */\n  show(viewOptions) {\n    if(this._isShown) {\n      throw new Marionette.Error({\n        name: 'ComponentShowError',\n        message: 'Component has already been shown in a region.'\n      });\n    }\n\n    if(!this.region) {\n      throw new Marionette.Error({\n        name: 'ComponentRegionError',\n        message: 'Component has no defined region.'\n      });\n    }\n\n    this.triggerMethod('before:show');\n\n    this.renderView(viewOptions);\n    this._isShown = true;\n\n    this.triggerMethod('show');\n\n    // Destroy the component if the region is emptied because\n    // it destroys the view\n    this.listenTo(this.region, 'empty', this._destroy);\n\n    return this;\n  },\n\n  /**\n   * Get the Component ViewClass class.\n   * Checks if the `ViewClass` is a view class (the common case)\n   * Then check if it's a function (which we assume that returns a view class)\n   *\n   * @private\n   * @method _getViewClass\n   * @memberOf Component\n   * @param {Object} [options] - Options that can be used to determine the ViewClass.\n   * @returns {View}\n   */\n  _getViewClass(options = {}) {\n    const ViewClass = this.ViewClass;\n\n    if(ViewClass.prototype instanceof Backbone.View || ViewClass === Backbone.View) {\n      return ViewClass;\n    } else if(_.isFunction(ViewClass)) {\n      return ViewClass.call(this, options);\n    }\n\n    throw new Marionette.Error({\n      name: 'InvalidViewClassError',\n      message: '\"ViewClass\" must be a view class or a function that returns a view class'\n    });\n  },\n\n  /**\n   * Shows or re-shows a newly built view in the component's region\n   *\n   * @public\n   * @event Component#before:render:view\n   * @event Component#render:view\n   * @method renderView\n   * @memberOf Component\n   * @param {Object} [options] - Options hash mixed into the instantiated ViewClass.\n   * @returns {Component}\n   */\n  renderView(options) {\n    const ViewClass = this._getViewClass(options);\n\n    const viewOptions = this.mixinOptions(options);\n\n    const view = this.buildView(ViewClass, viewOptions);\n\n    // Attach current built view to component\n    this.currentView = view;\n\n    this._proxyViewEvents(view);\n\n    this.triggerMethod('before:render:view', view);\n\n    // _shouldDestroy is flag that prevents the Component from being\n    // destroyed if the region is emptied by Component itself.\n    this._shouldDestroy = false;\n\n    // Show the view in the region\n    this.region.show(view);\n\n    this._shouldDestroy = true;\n\n    this.triggerMethod('render:view', view);\n\n    return this;\n  },\n\n  /**\n   * Proxies the ViewClass's viewEvents to the Component itself\n   * Similar to CollectionView childEvents\n   * (http://marionettejs.com/docs/v2.3.2/marionette.collectionview.html#collectionviews-childevents)\n   *\n   * @private\n   * @method _proxyViewEvents\n   * @memberOf Component\n   * @param {Mn.ItemView|Mn.CollectionView|Mn.CompositeView|Mn.LayoutView} view -\n   * The instantiated ViewClass.\n   */\n  _proxyViewEvents(view) {\n    const prefix = this.viewEventPrefix;\n\n    view.on('all', function() {\n      const args = _.toArray(arguments);\n      const rootEvent = args[0];\n\n      args[0] = `${ prefix }:${ rootEvent }`;\n      args.splice(1, 0, view);\n\n      this.triggerMethod.apply(this, args);\n    }, this);\n  },\n\n  /**\n   * Mixin initial State with any other viewOptions\n   *\n   * @public\n   * @abstract\n   * @method mixinOptions\n   * @memberOf Component\n   * @param {Object} [options] - Additional options to mixin\n   * @returns {Object}\n   */\n  mixinOptions(options) {\n    const viewOptions = _.result(this, 'viewOptions');\n\n    return _.extend({ state: this.getState().attributes }, viewOptions, options);\n  },\n\n  /**\n   * Builds the view class with options\n   * If you need a dynamic ViewClass override this function\n   *\n   * @public\n   * @abstract\n   * @method buildView\n   * @memberOf Component\n   * @param {Mn.ItemView|Mn.CollectionView|Mn.CompositeView|Mn.LayoutView} ViewClass -\n   * The view class to instantiate.\n   * @param {Object} [viewOptions] - Options to pass to the View\n   * @returns {Mn.ItemView|Mn.CollectionView|Mn.CompositeView|Mn.LayoutView}\n   */\n  buildView(ViewClass, viewOptions) {\n    return new ViewClass(viewOptions);\n  },\n\n  /**\n   * Destroys Component.\n   *\n   * @private\n   * @method _destroy\n   * @memberOf Component\n   */\n  _destroy() {\n    if(this._shouldDestroy) {\n      Marionette.Object.prototype.destroy.apply(this, arguments);\n    }\n  },\n\n  /**\n   * Empties component's region.\n   *\n   * @private\n   * @method _emptyRegion\n   * @param {Object} [options] - Options passed to `region.empty`\n   * @memberOf Component\n   */\n  _emptyRegion(options) {\n    if(this.region) {\n      this.stopListening(this.region, 'empty');\n      this.region.empty(options);\n    }\n  },\n\n  /**\n   * Empty the region and destroy the component.\n   *\n   * @public\n   * @method destroy\n   * @param {Object} [options] - Options passed to `_emptyRegion` and `destroy`\n   * @memberOf Component\n   */\n  destroy(options) {\n    this._emptyRegion(options);\n\n    this._shouldDestroy = true;\n\n    this._destroy(options);\n  }\n});\n\n_.extend(Component.prototype, StateMixin);\n\nexport default Component;\n","import Marionette from 'backbone.marionette';\n\nimport StateMixin from './mixins/state';\nimport App from './app';\nimport Component from './component';\n\n/**\n * @module Toolkit\n */\n\nconst previousToolkit = Marionette.Toolkit;\n\nconst Toolkit = Marionette.Toolkit = {};\n\nToolkit.noConflict = function() {\n  Marionette.Toolkit = previousToolkit;\n  return this;\n};\n\nToolkit.MixinState = function(classDefinition) {\n  let _StateMixin = StateMixin;\n\n  if(classDefinition.prototype.StateModel) {\n    _StateMixin = _.omit(StateMixin, 'StateModel');\n  }\n\n  _.extend(classDefinition.prototype, _StateMixin);\n};\n\nToolkit.VERSION = '<%VERSION%>';\n\nToolkit.StateMixin = StateMixin;\n\nToolkit.App = App;\n\nToolkit.Component = Component;\n\nexport default Toolkit;\n"],"sourceRoot":"/source/"}